"""
VIP Premium Bot - Multi Payment Gateway Edition
================================================

Fitur:
- Privasi terjamin (admin info tersembunyi)
- Respon singkat & rapi
- Support Testnet untuk testing
- UI/UX yang lebih baik
- Multi Payment Gateway: CryptoPay, KkPay, OkayPay

SETUP:
1. Dapatkan BOT_TOKEN dari @BotFather
2. Dapatkan CRYPTOPAY_TOKEN dari @CryptoBot -> Crypto Pay -> My Apps
3. Set KKPAY_ID dan KKPAY_SECRET dari KkPay merchant panel
4. Set OKAYPAY_ID dan OKAYPAY_TOKEN dari OkayPay merchant panel
5. Set USE_TESTNET = True untuk testing (gunakan @CryptoTestnetBot)
6. Set USE_TESTNET = False untuk production
"""

import telebot
from telebot import types
import asyncio
import json
import os
import requests
import hashlib
import base64
from datetime import datetime
from urllib.parse import urlencode
from aiocryptopay import AioCryptoPay, Networks
from aiocryptopay.const import PaidButtons, CurrencyType

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KONFIGURASI UTAMA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Bot Token dari @BotFather
BOT_TOKEN = '6613883967:AAGNJ7oJQIbWZ-snY_dqy9rGDw_6nXbUrpY'

# CryptoPay Token
# TESTNET: Dari @CryptoTestnetBot -> Crypto Pay -> My Apps
# MAINNET: Dari @CryptoBot -> Crypto Pay -> My Apps
CRYPTOPAY_TOKEN = '519883:AAJsQ1LRbcYeeGw0RivIRdACWjpZGW8VGfL'

# KkPay Configuration
# Dapatkan dari https://www.gamepay.tech merchant panel
KKPAY_ID = '8138'
KKPAY_SECRET = 'e0e5a098fc93c156cfdad9d43e9a3417'

# OkayPay Configuration
# Dapatkan dari https://okaypay.me merchant panel
OKAYPAY_ID = '27994'
OKAYPAY_TOKEN = '98Vd6feiQGUqglxABsKOSW02r4Jw7Za'

# âš ï¸ TESTNET MODE - Set True untuk testing, False untuk production
USE_TESTNET = False

# Link Premium Channel (private invite link)
PREMIUM_LINK = 'https://t.me/+RczGHAYyuPthMjll'

# Admin ID (untuk notifikasi internal saja, tidak ditampilkan ke user)
ADMIN_ID = 6683929810

# Pricing
ORIGINAL_PRICE = 300
DISCOUNT_PERCENT = 50
FINAL_PRICE = ORIGINAL_PRICE * (100 - DISCOUNT_PERCENT) / 100

# Default Coin for KkPay & OkayPay
DEFAULT_COIN = 'USDT'

# Database Files
PREMIUM_DB = 'premium_users.json'
INVOICES_DB = 'pending_invoices.json'

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KKPAY PAYMENT GATEWAY CLASS
# Based on KkPay API Documentation
# API URL: https://www.gamepay.tech/merchant/
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class KkPay:
    """
    KkPay Payment Gateway
    
    API Endpoints:
    - /merchant/payLink - Create payment link
    - /merchant/createWithdrawOrder - Create withdrawal order
    - /merchant/checkDeposit - Check deposit order status
    - /merchant/checkWithdraw - Check withdrawal order status
    - /api/merchant/censorUserByTGID - Check if user exists
    
    Authentication:
    - Headers: KKPAY-ID, KKPAY-SIGN
    - Data is base64 encoded
    - Signature: base64(SHA-256(base64_data + secret))
    
    Response:
    - code: 1000 for success
    - message: Error message
    - data: Base64 encoded JSON data
    """
    
    def __init__(self, merchant_id: str, secret: str):
        self.id = merchant_id
        self.secret = secret
        self.api_url = 'https://www.gamepay.tech/merchant/'
        
    def sign(self, data: str) -> str:
        """
        Generate signature for data
        Args:
            data: base64 encoded JSON string
        Returns:
            Base64 encoded SHA256 hash
        """
        message = data + self.secret
        hash_bytes = hashlib.sha256(message.encode('utf-8')).digest()
        signature = base64.b64encode(hash_bytes).decode('utf-8')
        return signature
    
    def check_sign(self, data: str, received_signature: str) -> bool:
        """
        Verify signature
        Args:
            data: base64 encoded data
            received_signature: signature to verify
        Returns:
            True if signature is valid
        """
        expected_signature = self.sign(data)
        return expected_signature == received_signature
    
    def pay_link(self, amount: float, coin: str = 'USDT', user_order: str = None, 
                 name: str = None, return_url: str = None) -> dict:
        """
        Create payment link
        
        Args:
            amount: Payment amount (required) - auto truncated to 2 decimals
            coin: Currency type - USDT, TRX, CNY, KKCOIN (required)
            user_order: Customer order ID (optional, unique - duplicates return previous data)
            name: Display text during payment (optional)
            return_url: Return URL after payment (optional)
            
        Returns:
            dict with:
            - status: True/False
            - data: {txid, amount, currency, fee, pay_url}
        """
        data = {
            'amount': float(amount),
            'coin': coin
        }
        if user_order:
            data['userOrder'] = user_order
        if name:
            data['name'] = name
        if return_url:
            data['return_url'] = return_url
        
        return self._post(self.api_url + 'payLink', data)
    
    def check_deposit(self, txid: str) -> dict:
        """
        Check deposit order status
        
        Args:
            txid: KkPay order ID (required)
            
        Returns:
            dict with:
            - status: True/False
            - data: {txid, amount, currency, fee, statusText, name, payUser}
            - statusText values: padding (unpaid), success (paid), fail (expired)
        """
        data = {
            'txid': txid
        }
        return self._post(self.api_url + 'checkDeposit', data)
    
    def create_withdraw_order(self, amount: float, to_user_id: int, coin: str = 'USDT',
                              user_order: str = None, name: str = None) -> dict:
        """
        Create withdrawal order to transfer to user
        
        Args:
            amount: Amount to transfer (required)
            to_user_id: Telegram user ID (required) - user must have started KkPay
            coin: Currency type - USDT, TRX, CNY, KKCOIN (required)
            user_order: Customer order ID (optional)
            name: Display note when user receives (optional)
            
        Returns:
            dict with:
            - status: True/False
            - data: {txid, amount, currency, fee, userOrder, name}
        """
        data = {
            'amount': float(amount),
            'to_user_id': int(to_user_id),
            'coin': coin
        }
        if user_order:
            data['userOrder'] = user_order
        if name:
            data['name'] = name
        
        return self._post(self.api_url + 'createWithdrawOrder', data)
    
    def check_withdraw(self, txid: str) -> dict:
        """
        Check withdrawal order status
        
        Args:
            txid: KkPay order ID (required)
            
        Returns:
            dict with:
            - status: True/False
            - data: {txid, amount, currency, fee, orderStatus, name, userOrder, to_user_id}
            - orderStatus values: padding (processing), success (completed), fail (failed)
        """
        data = {
            'txid': txid
        }
        return self._post(self.api_url + 'checkWithdraw', data)
    
    def check_user_exists(self, tg_id: str) -> dict:
        """
        Check if Telegram user exists/has started KkPay bot
        
        Args:
            tg_id: Telegram ID (required)
            
        Returns:
            dict with:
            - status: True/False
            - data: {tg_id, isExist}
        """
        data = {
            'tg_id': str(tg_id)
        }
        return self._post('https://www.gamepay.tech/api/merchant/censorUserByTGID', data)
    
    def _post(self, url: str, data: dict) -> dict:
        """
        Send POST request to API
        
        Args:
            url: API endpoint URL
            data: Request data
            
        Returns:
            dict with status and response data
        """
        try:
            # Encode data to base64
            json_data = json.dumps(data)
            b64_data = base64.b64encode(json_data.encode('utf-8')).decode('utf-8')
            sign = self.sign(b64_data)
            
            headers = {
                'Content-Type': 'text/plain',
                'KKPAY-SIGN': sign,
                'KKPAY-ID': self.id,
                'User-Agent': 'HTTP CLIENT'
            }
            
            response = requests.post(url, data=b64_data, headers=headers, timeout=15)
            
            # Get signature from response headers
            response_sign = response.headers.get('KKPAY-SIGN', '')
            
            # Parse response
            if response.text == 'Oops':
                return {
                    'status': False,
                    'message': 'IP whitelist error - add server IP to KkPay merchant panel'
                }
            
            try:
                result = response.json()
            except json.JSONDecodeError:
                return {
                    'status': False,
                    'message': f'Invalid JSON response: {response.text[:100]}'
                }
            
            # Check for success (code 1000 or 10000 based on API version)
            if result.get('code') in [1000, 10000]:
                response_data = result.get('data', '')
                
                # Verify response signature if present
                if response_sign and response_data:
                    if not self.check_sign(response_data, response_sign):
                        return {
                            'status': False,
                            'message': 'Response signature verification failed'
                        }
                
                # Decode response data (base64 encoded JSON)
                if response_data:
                    try:
                        decoded_data = json.loads(base64.b64decode(response_data).decode('utf-8'))
                        return {
                            'status': True,
                            'data': decoded_data
                        }
                    except Exception as e:
                        return {
                            'status': False,
                            'message': f'Failed to decode response data: {str(e)}'
                        }
                
                return {'status': True, 'data': result}
            else:
                return {
                    'status': False,
                    'message': result.get('message', f'API error code: {result.get("code")}'),
                    'code': result.get('code')
                }
                
        except requests.exceptions.Timeout:
            return {'status': False, 'message': 'Request timeout - try again'}
        except requests.exceptions.ConnectionError:
            return {'status': False, 'message': 'Connection error - check network'}
        except requests.exceptions.RequestException as e:
            return {'status': False, 'message': f'Request error: {str(e)}'}
        except Exception as e:
            return {'status': False, 'message': f'Unexpected error: {str(e)}'}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# OKAYPAY PAYMENT GATEWAY CLASS
# Based on OkayPay API Documentation
# API URL: https://api.okaypay.me/shop/
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OkayPay:
    """
    OkayPay Payment Gateway
    
    API Endpoints:
    - /shop/payLink - Create payment link
    - /shop/transfer - Transfer to user
    - /shop/TransactionHistory - Get transaction history
    
    Authentication:
    - Data includes merchant id and sign
    - Sign: MD5(sorted_params + &token=xxx).upper()
    """
    
    def __init__(self, merchant_id: str, token: str):
        self.id = merchant_id
        self.token = token
        self.api_url = 'https://api.okaypay.me/shop/'
        
    def sign(self, data: dict) -> dict:
        """
        Generate signature for data
        
        Args:
            data: Request data dict
            
        Returns:
            Data dict with added id and sign
        """
        data = data.copy()
        data['id'] = self.id
        
        # Remove empty/None values
        data = {k: v for k, v in data.items() if v is not None and v != ''}
        
        # Sort by key
        sorted_data = dict(sorted(data.items()))
        
        # Build query string and add token
        query_string = urlencode(sorted_data) + '&token=' + self.token
        
        # Calculate MD5 hash (uppercase)
        sign = hashlib.md5(query_string.encode('utf-8')).hexdigest().upper()
        sorted_data['sign'] = sign
        
        return sorted_data
    
    def check_sign(self, data: dict) -> bool:
        """
        Verify signature
        
        Args:
            data: Response data with sign
            
        Returns:
            True if signature is valid
        """
        received_sign = data.get('sign', '')
        data_copy = data.copy()
        if 'sign' in data_copy:
            del data_copy['sign']
        
        # Remove empty/None values
        data_copy = {k: v for k, v in data_copy.items() if v is not None and v != ''}
        
        # Sort by key
        sorted_data = dict(sorted(data_copy.items()))
        
        # Build query string and add token
        query_string = urlencode(sorted_data) + '&token=' + self.token
        
        # Calculate MD5 hash (uppercase)
        expected_sign = hashlib.md5(query_string.encode('utf-8')).hexdigest().upper()
        
        return received_sign == expected_sign
    
    def pay_link(self, amount: float, coin: str = 'USDT', unique_id: str = None,
                 name: str = None, return_url: str = None) -> dict:
        """
        Create payment link
        
        Args:
            amount: Payment amount (required)
            coin: Currency type - USDT or TRX (required)
            unique_id: Unique order ID (optional)
            name: Display name (optional)
            return_url: Return URL after payment (optional)
            
        Returns:
            dict with API response
        """
        data = {
            'amount': float(amount),
            'coin': coin
        }
        if unique_id:
            data['unique_id'] = unique_id
        if name:
            data['name'] = name
        if return_url:
            data['return_url'] = return_url
        
        return self._post(self.api_url + 'payLink', data)
    
    def transfer(self, amount: float, to_user_id: int, coin: str = 'USDT',
                 unique_id: str = None, name: str = None) -> dict:
        """
        Transfer to user
        
        Args:
            amount: Amount to transfer (required)
            to_user_id: Telegram user ID (required)
            coin: Currency type - USDT or TRX (required)
            unique_id: Unique order ID (optional)
            name: Display name (optional)
            
        Returns:
            dict with API response
        """
        data = {
            'amount': float(amount),
            'to_user_id': int(to_user_id),
            'coin': coin
        }
        if unique_id:
            data['unique_id'] = unique_id
        if name:
            data['name'] = name
        
        return self._post(self.api_url + 'transfer', data)
    
    def transaction_history(self, page: int = 1, limit: int = 20) -> dict:
        """
        Get transaction history
        
        Args:
            page: Page number
            limit: Items per page
            
        Returns:
            dict with transaction history
        """
        data = {
            'page': int(page),
            'limit': int(limit)
        }
        return self._post(self.api_url + 'TransactionHistory', data)
    
    def _post(self, url: str, data: dict) -> dict:
        """
        Send POST request to API
        
        Args:
            url: API endpoint URL
            data: Request data
            
        Returns:
            dict with API response
        """
        try:
            signed_data = self.sign(data)
            
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': 'HTTP CLIENT'
            }
            
            response = requests.post(url, data=urlencode(signed_data), 
                                    headers=headers, timeout=15)
            
            try:
                result = response.json()
            except json.JSONDecodeError:
                return {
                    'status': False,
                    'message': f'Invalid JSON response: {response.text[:100]}'
                }
            
            # Add status field for consistency
            if result.get('code') in [1000, 10000]:
                result['status'] = True
            else:
                result['status'] = False
            
            return result
            
        except requests.exceptions.Timeout:
            return {'status': False, 'message': 'Request timeout - try again'}
        except requests.exceptions.ConnectionError:
            return {'status': False, 'message': 'Connection error - check network'}
        except requests.exceptions.RequestException as e:
            return {'status': False, 'message': f'Request error: {str(e)}'}
        except Exception as e:
            return {'status': False, 'message': f'Unexpected error: {str(e)}'}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INISIALISASI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bot = telebot.TeleBot(BOT_TOKEN)
NETWORK = Networks.TEST_NET if USE_TESTNET else Networks.MAIN_NET

# Initialize Payment Gateways
kkpay = KkPay(KKPAY_ID, KKPAY_SECRET)
okaypay = OkayPay(OKAYPAY_ID, OKAYPAY_TOKEN)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATABASE HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_json(file):
    """Load data dari JSON file"""
    if os.path.exists(file):
        try:
            with open(file, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_json(file, data):
    """Simpan data ke JSON file"""
    with open(file, 'w') as f:
        json.dump(data, f, indent=2)

# Premium Users
def is_premium(user_id):
    return str(user_id) in load_json(PREMIUM_DB)

def get_premium_data(user_id):
    return load_json(PREMIUM_DB).get(str(user_id))

def add_premium(user_id, invoice_id, gateway='cryptopay'):
    data = load_json(PREMIUM_DB)
    data[str(user_id)] = {
        'invoice_id': invoice_id,
        'activated': datetime.now().isoformat(),
        'amount': FINAL_PRICE,
        'gateway': gateway
    }
    save_json(PREMIUM_DB, data)

# Pending Invoices
def get_invoice(user_id):
    return load_json(INVOICES_DB).get(str(user_id))

def save_invoice(user_id, invoice_id, url, gateway='cryptopay', txid=None):
    data = load_json(INVOICES_DB)
    data[str(user_id)] = {
        'id': invoice_id,
        'url': url,
        'gateway': gateway,
        'txid': txid,  # KkPay transaction ID for verification
        'created': datetime.now().isoformat()
    }
    save_json(INVOICES_DB, data)

def remove_invoice(user_id):
    data = load_json(INVOICES_DB)
    if str(user_id) in data:
        del data[str(user_id)]
        save_json(INVOICES_DB, data)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRYPTOPAY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def create_cryptopay_invoice(user_id):
    """Buat invoice pembayaran via CryptoPay"""
    crypto = AioCryptoPay(token=CRYPTOPAY_TOKEN, network=NETWORK)
    
    try:
        bot_info = bot.get_me().username
        invoice = await crypto.create_invoice(
            amount=FINAL_PRICE,
            fiat='USD',
            currency_type=CurrencyType.FIAT,
            description='VIP Premium Lifetime',
            paid_btn_name=PaidButtons.CALLBACK,
            paid_btn_url=f'https://t.me/{bot_info}?start=paid',
            payload=str(user_id),
            allow_comments=False,
            allow_anonymous=True
        )
        return invoice
    finally:
        await crypto.close()

async def check_cryptopay_invoice(invoice_id):
    """Cek status invoice CryptoPay"""
    crypto = AioCryptoPay(token=CRYPTOPAY_TOKEN, network=NETWORK)
    
    try:
        invoices = await crypto.get_invoices(invoice_ids=[invoice_id])
        return invoices[0] if invoices else None
    finally:
        await crypto.close()

async def get_cryptopay_info():
    """Get CryptoPay app info"""
    crypto = AioCryptoPay(token=CRYPTOPAY_TOKEN, network=NETWORK)
    
    try:
        return await crypto.get_me()
    finally:
        await crypto.close()

def run_async(coro):
    """Helper async runner"""
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(coro)
    except Exception as e:
        raise e

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KKPAY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_kkpay_invoice(user_id):
    """Buat invoice pembayaran via KkPay"""
    user_order = f"kk_{user_id}_{int(datetime.now().timestamp())}"
    
    result = kkpay.pay_link(
        amount=FINAL_PRICE,
        coin=DEFAULT_COIN,
        user_order=user_order,
        name='VIP Premium Lifetime'
    )
    
    return result

def check_kkpay_payment(txid: str):
    """Check KkPay payment status by txid"""
    return kkpay.check_deposit(txid)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# OKAYPAY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_okaypay_invoice(user_id):
    """Buat invoice pembayaran via OkayPay"""
    unique_id = f"okpay_{user_id}_{int(datetime.now().timestamp())}"
    
    result = okaypay.pay_link(
        amount=FINAL_PRICE,
        coin=DEFAULT_COIN,
        unique_id=unique_id,
        name='VIP Premium Lifetime'
    )
    
    return result

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MESSAGE TEMPLATES (Singkat & Rapi)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def msg_welcome():
    """Pesan welcome untuk user baru"""
    mode = "ðŸ§ª TESTNET" if USE_TESTNET else "ðŸ” SECURE"
    return f"""
ðŸŽ¬ *VIP Premium Bot* {mode}

Akses *10.000+ video premium* berkualitas tinggi!

âœ¨ *Keuntungan:*
â€¢ Akses eksklusif seumur hidup
â€¢ Update harian & privasi 100%

ðŸ’° *Harga:* ~~${ORIGINAL_PRICE}~~ â†’ *${int(FINAL_PRICE)}* (-{DISCOUNT_PERCENT}%)
"""

def msg_welcome_premium():
    """Pesan untuk member premium"""
    return """
ðŸŽ‰ *Welcome Back, VIP!*

Status: âœ… *PREMIUM LIFETIME*

Klik tombol untuk akses konten ðŸ‘‡
"""

def msg_select_payment():
    """Pesan pilih metode pembayaran"""
    return f"""
ðŸ’³ *Pilih Metode Pembayaran*

ðŸ“¦ Produk: VIP Premium Lifetime
ðŸ’µ Total: *${int(FINAL_PRICE)}*

Pilih payment gateway di bawah:
"""

def msg_invoice(invoice_id, gateway='cryptopay'):
    """Pesan invoice pembayaran"""
    mode = "ðŸ§ª Mode: TESTNET" if USE_TESTNET else ""
    gateway_name = {
        'cryptopay': 'ðŸ”· CryptoPay',
        'kkpay': 'ðŸŸ¡ KkPay',
        'okaypay': 'ðŸŸ¢ OkayPay'
    }.get(gateway, gateway)
    
    return f"""
ðŸ’³ *Invoice Pembayaran*

ðŸ“¦ VIP Premium Lifetime
ðŸ’µ Total: *${int(FINAL_PRICE)}*
ðŸ¦ Gateway: {gateway_name}
ðŸ”¢ ID: `{invoice_id}`
{mode}

*Cara Bayar:*
1ï¸âƒ£ Klik "Bayar Sekarang"
2ï¸âƒ£ Pilih crypto & bayar
3ï¸âƒ£ Klik "Verifikasi" setelah bayar

â° Berlaku 60 menit
"""

def msg_success(invoice_id):
    """Pesan pembayaran sukses"""
    return f"""
âœ… *Pembayaran Berhasil!*

ðŸŽ‰ Selamat! Kamu sekarang *VIP Member*
â° Durasi: *LIFETIME*

Klik tombol untuk akses premium ðŸ‘‡
"""

def msg_pending(invoice_id):
    """Pesan menunggu pembayaran"""
    return f"""
â³ *Menunggu Pembayaran*

ðŸ”¢ Invoice: `{invoice_id}`
ðŸ“Š Status: Belum dibayar

Selesaikan pembayaran terlebih dahulu.
"""

def msg_expired():
    """Pesan invoice expired"""
    return """
âŒ› *Invoice Kadaluarsa*

Buat invoice baru untuk melanjutkan.
"""

def msg_error():
    """Pesan error"""
    return """
âŒ *Terjadi Kesalahan*

Coba lagi atau hubungi support.
"""

def msg_cancelled():
    """Pesan dibatalkan"""
    return """
ðŸš« *Dibatalkan*

Ketik /start untuk memulai kembali.
"""

def msg_status_free():
    """Status user free"""
    return f"""
ðŸ“Š *Status Keanggotaan*

ðŸ”“ Status: *FREE*

Upgrade ke Premium:
â€¢ 10.000+ video
â€¢ Akses lifetime
â€¢ Hanya *${int(FINAL_PRICE)}*
"""

def msg_status_premium(data):
    """Status user premium"""
    date = data['activated'][:10]
    gateway = data.get('gateway', 'cryptopay')
    gateway_name = {
        'cryptopay': 'CryptoPay',
        'kkpay': 'KkPay',
        'okaypay': 'OkayPay'
    }.get(gateway, gateway)
    
    return f"""
ðŸ“Š *Status Keanggotaan*

âœ… Status: *PREMIUM*
ðŸ“… Sejak: {date}
â° Durasi: *LIFETIME*
ðŸ¦ Gateway: {gateway_name}
"""

def msg_help():
    """Pesan bantuan"""
    return """
ðŸ“š *Bantuan*

/start - Menu utama
/status - Cek keanggotaan
/help - Bantuan

*Cara Beli:*
1. Klik "Beli Premium"
2. Pilih payment gateway
3. Bayar dengan crypto
4. Verifikasi pembayaran
5. Akses premium!

*Payment Gateway:*
ðŸ”· CryptoPay - USDT, TON, BTC, ETH
ðŸŸ¡ KkPay - USDT, TRX
ðŸŸ¢ OkayPay - USDT, TRX
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# KEYBOARDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def kb_main():
    """Keyboard menu utama"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ’Ž Beli Premium", callback_data='buy'),
        types.InlineKeyboardButton("ðŸ“Š Status", callback_data='status'),
        types.InlineKeyboardButton("â“ Bantuan", callback_data='help')
    )
    return kb

def kb_premium():
    """Keyboard untuk premium user"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ”“ Akses Premium", url=PREMIUM_LINK),
        types.InlineKeyboardButton("ðŸ“Š Status", callback_data='status')
    )
    return kb

def kb_payment_methods():
    """Keyboard pilih metode pembayaran"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ”· CryptoPay (USDT/TON/BTC)", callback_data='pay_cryptopay'),
        types.InlineKeyboardButton("ðŸŸ¡ KkPay (USDT/TRX)", callback_data='pay_kkpay'),
        types.InlineKeyboardButton("ðŸŸ¢ OkayPay (USDT/TRX)", callback_data='pay_okaypay'),
        types.InlineKeyboardButton("âŒ Batal", callback_data='cancel')
    )
    return kb

def kb_invoice(invoice_url, invoice_id, gateway='cryptopay'):
    """Keyboard invoice"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ’° Bayar Sekarang", url=invoice_url),
        types.InlineKeyboardButton("âœ… Verifikasi", callback_data=f'verify_{gateway}_{invoice_id}'),
        types.InlineKeyboardButton("âŒ Batal", callback_data='cancel')
    )
    return kb

def kb_pending(invoice_url, invoice_id, gateway='cryptopay'):
    """Keyboard pending payment"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ’° Bayar", url=invoice_url),
        types.InlineKeyboardButton("ðŸ”„ Cek Ulang", callback_data=f'verify_{gateway}_{invoice_id}')
    )
    return kb

def kb_success():
    """Keyboard sukses"""
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("ðŸ”“ Akses Premium", url=PREMIUM_LINK))
    return kb

def kb_retry():
    """Keyboard retry"""
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.add(
        types.InlineKeyboardButton("ðŸ”„ Coba Lagi", callback_data='buy'),
        types.InlineKeyboardButton("ðŸ  Menu", callback_data='menu')
    )
    return kb

def kb_back():
    """Keyboard back"""
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("ðŸ  Menu Utama", callback_data='menu'))
    return kb

def kb_status_free():
    """Keyboard status free"""
    kb = types.InlineKeyboardMarkup(row_width=1)
    kb.add(
        types.InlineKeyboardButton("ðŸ’Ž Upgrade Premium", callback_data='buy'),
        types.InlineKeyboardButton("ðŸ  Menu", callback_data='menu')
    )
    return kb

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BOT HANDLERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@bot.message_handler(commands=['start'])
def cmd_start(message):
    """Handle /start command"""
    user_id = message.from_user.id
    args = message.text.split()
    
    # Deep link handler
    if len(args) > 1:
        if args[1] == 'paid' or args[1].startswith('paid_'):
            pending = get_invoice(user_id)
            if pending:
                gateway = pending.get('gateway', 'cryptopay')
                txid = pending.get('txid') or pending.get('id')
                verify_payment(message.chat.id, txid, user_id, gateway=gateway)
                return
    
    # Check premium status
    if is_premium(user_id):
        bot.send_message(
            message.chat.id,
            msg_welcome_premium(),
            parse_mode='Markdown',
            reply_markup=kb_premium()
        )
    else:
        bot.send_message(
            message.chat.id,
            msg_welcome(),
            parse_mode='Markdown',
            reply_markup=kb_main()
        )

@bot.message_handler(commands=['status'])
def cmd_status(message):
    """Handle /status command"""
    show_status(message.chat.id, message.from_user.id)

@bot.message_handler(commands=['help'])
def cmd_help(message):
    """Handle /help command"""
    bot.send_message(
        message.chat.id,
        msg_help(),
        parse_mode='Markdown',
        reply_markup=kb_back()
    )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CALLBACK HANDLERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@bot.callback_query_handler(func=lambda c: c.data == 'menu')
def cb_menu(call):
    """Back to menu"""
    user_id = call.from_user.id
    
    if is_premium(user_id):
        bot.edit_message_text(
            msg_welcome_premium(),
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_premium()
        )
    else:
        bot.edit_message_text(
            msg_welcome(),
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_main()
        )
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data == 'buy')
def cb_buy(call):
    """Handle buy premium - show payment methods"""
    user_id = call.from_user.id
    
    if is_premium(user_id):
        bot.answer_callback_query(call.id, "âœ… Kamu sudah premium!", show_alert=True)
        return
    
    bot.edit_message_text(
        msg_select_payment(),
        call.message.chat.id,
        call.message.message_id,
        parse_mode='Markdown',
        reply_markup=kb_payment_methods()
    )
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data == 'pay_cryptopay')
def cb_pay_cryptopay(call):
    """Handle CryptoPay payment"""
    user_id = call.from_user.id
    
    if is_premium(user_id):
        bot.answer_callback_query(call.id, "âœ… Kamu sudah premium!", show_alert=True)
        return
    
    bot.answer_callback_query(call.id, "â³ Membuat invoice CryptoPay...")
    
    try:
        bot.edit_message_text(
            "â³ *Membuat invoice CryptoPay...*",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown'
        )
    except:
        pass
    
    try:
        invoice = run_async(create_cryptopay_invoice(user_id))
        save_invoice(user_id, invoice.invoice_id, invoice.bot_invoice_url, 'cryptopay')
        
        bot.edit_message_text(
            msg_invoice(invoice.invoice_id, 'cryptopay'),
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_invoice(invoice.bot_invoice_url, invoice.invoice_id, 'cryptopay')
        )
        
    except Exception as e:
        print(f"Error creating CryptoPay invoice: {e}")
        bot.edit_message_text(
            msg_error(),
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_retry()
        )

@bot.callback_query_handler(func=lambda c: c.data == 'pay_kkpay')
def cb_pay_kkpay(call):
    """Handle KkPay payment"""
    user_id = call.from_user.id
    
    if is_premium(user_id):
        bot.answer_callback_query(call.id, "âœ… Kamu sudah premium!", show_alert=True)
        return
    
    bot.answer_callback_query(call.id, "â³ Membuat invoice KkPay...")
    
    try:
        bot.edit_message_text(
            "â³ *Membuat invoice KkPay...*",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown'
        )
    except:
        pass
    
    try:
        result = create_kkpay_invoice(user_id)
        
        if result.get('status'):
            data = result.get('data', {})
            # KkPay returns: txid, amount, currency, fee, pay_url
            txid = data.get('txid', '')
            pay_url = data.get('pay_url', '')
            
            if pay_url and txid:
                # Save with txid for verification
                save_invoice(user_id, txid, pay_url, 'kkpay', txid=txid)
                
                bot.edit_message_text(
                    msg_invoice(txid, 'kkpay'),
                    call.message.chat.id,
                    call.message.message_id,
                    parse_mode='Markdown',
                    reply_markup=kb_invoice(pay_url, txid, 'kkpay')
                )
            else:
                raise Exception(f"No payment URL or txid returned. Data: {data}")
        else:
            error_msg = result.get('message', 'Unknown KkPay error')
            raise Exception(error_msg)
            
    except Exception as e:
        print(f"Error creating KkPay invoice: {e}")
        bot.edit_message_text(
            f"âŒ *KkPay Error*\n\n{str(e)[:200]}\n\nCoba metode pembayaran lain.",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_retry()
        )

@bot.callback_query_handler(func=lambda c: c.data == 'pay_okaypay')
def cb_pay_okaypay(call):
    """Handle OkayPay payment"""
    user_id = call.from_user.id
    
    if is_premium(user_id):
        bot.answer_callback_query(call.id, "âœ… Kamu sudah premium!", show_alert=True)
        return
    
    bot.answer_callback_query(call.id, "â³ Membuat invoice OkayPay...")
    
    try:
        bot.edit_message_text(
            "â³ *Membuat invoice OkayPay...*",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown'
        )
    except:
        pass
    
    try:
        result = create_okaypay_invoice(user_id)
        
        if result.get('status') or result.get('code') in [1000, 10000]:
            data = result.get('data', result)
            invoice_id = data.get('order_id', f"ok_{user_id}_{int(datetime.now().timestamp())}")
            pay_url = data.get('pay_url', data.get('url', ''))
            
            if pay_url:
                save_invoice(user_id, invoice_id, pay_url, 'okaypay')
                
                bot.edit_message_text(
                    msg_invoice(invoice_id, 'okaypay'),
                    call.message.chat.id,
                    call.message.message_id,
                    parse_mode='Markdown',
                    reply_markup=kb_invoice(pay_url, invoice_id, 'okaypay')
                )
            else:
                raise Exception("No payment URL returned")
        else:
            raise Exception(result.get('message', 'OkayPay error'))
            
    except Exception as e:
        print(f"Error creating OkayPay invoice: {e}")
        bot.edit_message_text(
            f"âŒ *OkayPay Error*\n\n{str(e)[:200]}\n\nCoba metode pembayaran lain.",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown',
            reply_markup=kb_retry()
        )

@bot.callback_query_handler(func=lambda c: c.data.startswith('verify_'))
def cb_verify(call):
    """Verify payment"""
    parts = call.data.split('_', 2)
    if len(parts) >= 3:
        gateway = parts[1]
        invoice_id = parts[2]
    else:
        # Fallback for old format
        invoice_id = call.data.replace('verify_', '')
        gateway = 'cryptopay'
    
    user_id = call.from_user.id
    
    bot.answer_callback_query(call.id, "ðŸ” Memeriksa pembayaran...")
    verify_payment(call.message.chat.id, invoice_id, user_id, call.message.message_id, gateway)

@bot.callback_query_handler(func=lambda c: c.data == 'status')
def cb_status(call):
    """Show status"""
    show_status(call.message.chat.id, call.from_user.id, call.message.message_id)
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data == 'help')
def cb_help(call):
    """Show help"""
    bot.edit_message_text(
        msg_help(),
        call.message.chat.id,
        call.message.message_id,
        parse_mode='Markdown',
        reply_markup=kb_back()
    )
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data == 'cancel')
def cb_cancel(call):
    """Cancel payment"""
    bot.edit_message_text(
        msg_cancelled(),
        call.message.chat.id,
        call.message.message_id,
        parse_mode='Markdown',
        reply_markup=kb_back()
    )
    bot.answer_callback_query(call.id)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def verify_payment(chat_id, invoice_id, user_id, msg_id=None, gateway='cryptopay'):
    """Verify payment status based on gateway"""
    try:
        pending = get_invoice(user_id)
        
        if gateway == 'cryptopay':
            # Verify CryptoPay payment
            invoice = run_async(check_cryptopay_invoice(int(invoice_id)))
            
            if not invoice:
                text = msg_error()
                kb = kb_retry()
            elif invoice.status == 'paid':
                if not is_premium(user_id):
                    add_premium(user_id, invoice_id, 'cryptopay')
                remove_invoice(user_id)
                
                text = msg_success(invoice_id)
                kb = kb_success()
                notify_admin(user_id, invoice_id, 'cryptopay')
                
            elif invoice.status == 'active':
                text = msg_pending(invoice_id)
                kb = kb_pending(invoice.bot_invoice_url, invoice_id, 'cryptopay')
            else:
                text = msg_expired()
                kb = kb_retry()
                
        elif gateway == 'kkpay':
            # Verify KkPay payment using checkDeposit API
            txid = pending.get('txid') if pending else invoice_id
            result = check_kkpay_payment(txid)
            
            if result.get('status'):
                data = result.get('data', {})
                status_text = data.get('statusText', 'padding')
                
                if status_text == 'success':
                    # Payment successful
                    if not is_premium(user_id):
                        add_premium(user_id, txid, 'kkpay')
                    remove_invoice(user_id)
                    
                    text = msg_success(txid)
                    kb = kb_success()
                    notify_admin(user_id, txid, 'kkpay')
                    
                elif status_text == 'padding':
                    # Still waiting for payment
                    pay_url = pending.get('url', '') if pending else ''
                    text = msg_pending(txid)
                    kb = kb_pending(pay_url, txid, 'kkpay')
                    
                else:  # fail - expired
                    text = msg_expired()
                    kb = kb_retry()
                    remove_invoice(user_id)
            else:
                # API error
                error_msg = result.get('message', 'Unknown error')
                text = f"""
âŒ *Verifikasi Gagal*

Error: {error_msg[:100]}

Coba beberapa saat lagi.
"""
                pay_url = pending.get('url', '') if pending else ''
                kb = kb_pending(pay_url, invoice_id, 'kkpay') if pay_url else kb_retry()
                
        elif gateway == 'okaypay':
            # For OkayPay, we rely on webhook callbacks
            # Check if pending invoice exists
            if pending:
                text = f"""
â³ *Menunggu Konfirmasi*

ðŸ”¢ Invoice: `{invoice_id}`
ðŸ¦ Gateway: OkayPay

Pembayaran akan diverifikasi otomatis.
Jika sudah bayar, tunggu beberapa saat.
"""
                kb = kb_pending(pending.get('url', ''), invoice_id, gateway)
            else:
                text = msg_expired()
                kb = kb_retry()
        else:
            text = msg_error()
            kb = kb_retry()
        
        if msg_id:
            bot.edit_message_text(
                text, chat_id, msg_id,
                parse_mode='Markdown',
                reply_markup=kb
            )
        else:
            bot.send_message(
                chat_id, text,
                parse_mode='Markdown',
                reply_markup=kb
            )
            
    except Exception as e:
        print(f"Error verifying: {e}")
        if msg_id:
            bot.edit_message_text(
                msg_error(), chat_id, msg_id,
                parse_mode='Markdown',
                reply_markup=kb_retry()
            )
        else:
            bot.send_message(
                chat_id, msg_error(),
                parse_mode='Markdown',
                reply_markup=kb_retry()
            )

def show_status(chat_id, user_id, msg_id=None):
    """Show membership status"""
    if is_premium(user_id):
        data = get_premium_data(user_id)
        text = msg_status_premium(data)
        kb = kb_premium()
    else:
        text = msg_status_free()
        kb = kb_status_free()
    
    if msg_id:
        bot.edit_message_text(
            text, chat_id, msg_id,
            parse_mode='Markdown',
            reply_markup=kb
        )
    else:
        bot.send_message(
            chat_id, text,
            parse_mode='Markdown',
            reply_markup=kb
        )

def notify_admin(user_id, invoice_id, gateway='cryptopay'):
    """Notify admin about new payment"""
    try:
        gateway_name = {
            'cryptopay': 'ðŸ”· CryptoPay',
            'kkpay': 'ðŸŸ¡ KkPay',
            'okaypay': 'ðŸŸ¢ OkayPay'
        }.get(gateway, gateway)
        
        text = f"""
ðŸ”” *Pembayaran Baru*

ðŸ’° ${int(FINAL_PRICE)}
ðŸ¦ {gateway_name}
ðŸ”¢ Invoice: `{invoice_id}`
â° {datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        bot.send_message(ADMIN_ID, text, parse_mode='Markdown')
    except:
        pass

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WEBHOOK HANDLERS FOR KKPAY & OKAYPAY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def handle_kkpay_callback(data: dict, sign: str) -> dict:
    """
    Handle KkPay async notification callback
    
    Expected callback data (deposit):
    {
        "businessType": "deposit",
        "txid": "kkpay_order_id",
        "payUser": "telegram_user_id",
        "amount": 150.0,
        "currency": "usdt",
        "fee": 1.5,
        "userOrder": "your_order_id"
    }
    
    Returns:
        {'status': 'success'} on success
    """
    try:
        # Verify signature
        b64_data = base64.b64encode(json.dumps(data).encode('utf-8')).decode('utf-8')
        if not kkpay.check_sign(b64_data, sign):
            return {'status': 'error', 'message': 'Invalid signature'}
        
        business_type = data.get('businessType', '')
        
        if business_type == 'deposit':
            # Deposit payment completed
            user_order = data.get('userOrder', '')
            txid = data.get('txid', '')
            pay_user = data.get('payUser')
            
            if user_order and pay_user:
                # Extract user_id from userOrder (format: kk_USERID_TIMESTAMP)
                parts = user_order.split('_')
                if len(parts) >= 2:
                    user_id = int(parts[1])
                    
                    if not is_premium(user_id):
                        add_premium(user_id, txid, 'kkpay')
                        remove_invoice(user_id)
                        
                        # Notify user
                        try:
                            bot.send_message(
                                user_id,
                                msg_success(txid),
                                parse_mode='Markdown',
                                reply_markup=kb_success()
                            )
                        except:
                            pass
                        
                        # Notify admin
                        notify_admin(user_id, txid, 'kkpay')
                        
                        return {'status': 'success'}
        
        elif business_type == 'withdrawalPendingConfirm':
            # Withdrawal pending confirmation - respond success to confirm
            return {'status': 'success'}
            
        elif business_type == 'withdraw':
            # Withdrawal completed
            order_status = data.get('orderStatus', '')
            if order_status == 'success':
                return {'status': 'success'}
            else:
                return {'status': 'error', 'message': 'Withdrawal failed'}
        
        return {'status': 'error', 'message': 'Unknown business type'}
        
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

def handle_okaypay_callback(data: dict) -> dict:
    """
    Handle OkayPay async notification callback
    
    Expected callback data:
    {
        'id': merchant_id,
        'sign': signature,
        'status': 'success',
        'code': 10000,
        'data': {
            'order_id': 'api_order_id',
            'unique_id': 'your_order_id',
            'pay_user_id': 'telegram_user_id',
            'amount': 150.0,
            'coin': 'USDT'
        }
    }
    
    Returns:
        {'status': 'success'} on success
    """
    try:
        # Verify signature
        if not okaypay.check_sign(data):
            return {'status': 'error', 'message': 'Invalid signature'}
        
        if data.get('status') == 'success' and data.get('code') in [1000, 10000]:
            order_data = data.get('data', {})
            unique_id = order_data.get('unique_id', '')
            pay_user_id = order_data.get('pay_user_id')
            
            if pay_user_id and unique_id:
                # Extract user_id from unique_id (format: okpay_USERID_TIMESTAMP)
                parts = unique_id.split('_')
                if len(parts) >= 2:
                    user_id = int(parts[1])
                    
                    if not is_premium(user_id):
                        add_premium(user_id, unique_id, 'okaypay')
                        remove_invoice(user_id)
                        
                        # Notify user
                        try:
                            bot.send_message(
                                user_id,
                                msg_success(unique_id),
                                parse_mode='Markdown',
                                reply_markup=kb_success()
                            )
                        except:
                            pass
                        
                        # Notify admin
                        notify_admin(user_id, unique_id, 'okaypay')
                        
                        return {'status': 'success'}
        
        return {'status': 'error', 'message': 'Invalid data'}
        
    except Exception as e:
        return {'status': 'error', 'message': str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ADMIN COMMANDS (Hidden from regular users)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@bot.message_handler(commands=['admin'])
def cmd_admin(message):
    """Admin panel"""
    if message.from_user.id != ADMIN_ID:
        return
    
    users = load_json(PREMIUM_DB)
    total = len(users)
    revenue = sum(u.get('amount', 0) for u in users.values())
    mode = "ðŸ§ª TESTNET" if USE_TESTNET else "ðŸ” MAINNET"
    
    # Count by gateway
    gateway_counts = {}
    for u in users.values():
        gw = u.get('gateway', 'cryptopay')
        gateway_counts[gw] = gateway_counts.get(gw, 0) + 1
    
    gateway_stats = '\n'.join([f"  â€¢ {k}: {v}" for k, v in gateway_counts.items()])
    
    text = f"""
ðŸ”§ *Admin Panel*

{mode}
ðŸ‘¥ Premium: {total}
ðŸ’° Revenue: ${revenue}
ðŸ’µ Price: ${int(FINAL_PRICE)}

ðŸ“Š *By Gateway:*
{gateway_stats}

/testapi - Test CryptoPay
/testkkpay - Test KkPay
/testokaypay - Test OkayPay
/broadcast <msg> - Broadcast
/addpremium <user_id> - Add premium
"""
    bot.send_message(message.chat.id, text, parse_mode='Markdown')

@bot.message_handler(commands=['testapi'])
def cmd_testapi(message):
    """Test CryptoPay API"""
    if message.from_user.id != ADMIN_ID:
        return
    
    bot.reply_to(message, "ðŸ”„ Testing CryptoPay API...")
    
    try:
        info = run_async(get_cryptopay_info())
        mode = "TESTNET" if USE_TESTNET else "MAINNET"
        text = f"""
âœ… *CryptoPay API Connected*

ðŸ“± App: {info.name}
ðŸŒ Network: {mode}
"""
        bot.send_message(message.chat.id, text, parse_mode='Markdown')
    except Exception as e:
        bot.send_message(message.chat.id, f"âŒ CryptoPay Error: {str(e)[:200]}")

@bot.message_handler(commands=['testkkpay'])
def cmd_testkkpay(message):
    """Test KkPay API"""
    if message.from_user.id != ADMIN_ID:
        return
    
    bot.reply_to(message, "ðŸ”„ Testing KkPay API...")
    
    try:
        result = kkpay.pay_link(amount=1.0, coin='USDT', name='API Test')
        
        if result.get('status'):
            data = result.get('data', {})
            text = f"""
âœ… *KkPay API Connected*

ðŸ“± Merchant ID: {KKPAY_ID}
ðŸŒ API: gamepay.tech
ðŸ’° Test txid: `{data.get('txid', 'N/A')}`
ðŸ”— Pay URL: {data.get('pay_url', 'N/A')[:50]}...
"""
        else:
            text = f"âš ï¸ KkPay Error: {result.get('message', 'Unknown')}"
        bot.send_message(message.chat.id, text, parse_mode='Markdown')
    except Exception as e:
        bot.send_message(message.chat.id, f"âŒ KkPay Error: {str(e)[:200]}")

@bot.message_handler(commands=['testokaypay'])
def cmd_testokaypay(message):
    """Test OkayPay API"""
    if message.from_user.id != ADMIN_ID:
        return
    
    bot.reply_to(message, "ðŸ”„ Testing OkayPay API...")
    
    try:
        result = okaypay.pay_link(amount=1.0, coin='USDT', name='API Test')
        if result.get('status') or result.get('code') in [1000, 10000]:
            data = result.get('data', result)
            text = f"""
âœ… *OkayPay API Connected*

ðŸ“± Merchant ID: {OKAYPAY_ID}
ðŸŒ API: okaypay.me
ðŸ’° Test order_id: `{data.get('order_id', 'N/A')}`
"""
        else:
            text = f"âš ï¸ OkayPay Error: {result.get('message', 'Unknown')}"
        bot.send_message(message.chat.id, text, parse_mode='Markdown')
    except Exception as e:
        bot.send_message(message.chat.id, f"âŒ OkayPay Error: {str(e)[:200]}")

@bot.message_handler(commands=['addpremium'])
def cmd_addpremium(message):
    """Manually add premium user"""
    if message.from_user.id != ADMIN_ID:
        return
    
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Usage: /addpremium <user_id>")
        return
    
    try:
        target_user_id = int(args[1])
        add_premium(target_user_id, f"manual_{int(datetime.now().timestamp())}", 'manual')
        bot.reply_to(message, f"âœ… Added premium for user {target_user_id}")
    except ValueError:
        bot.reply_to(message, "âŒ Invalid user ID")

@bot.message_handler(commands=['broadcast'])
def cmd_broadcast(message):
    """Broadcast message to all premium users"""
    if message.from_user.id != ADMIN_ID:
        return
    
    text = message.text.replace('/broadcast', '').strip()
    if not text:
        bot.reply_to(message, "Usage: /broadcast <message>")
        return
    
    users = load_json(PREMIUM_DB)
    sent = 0
    
    for uid in users.keys():
        try:
            bot.send_message(int(uid), f"ðŸ“¢ *Pengumuman*\n\n{text}", parse_mode='Markdown')
            sent += 1
        except:
            pass
    
    bot.reply_to(message, f"âœ… Broadcast sent to {sent}/{len(users)} users")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEFAULT HANDLER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@bot.message_handler(func=lambda m: True)
def default_handler(message):
    """Handle unknown messages"""
    bot.reply_to(
        message,
        "Ketik /start untuk memulai ðŸ‘†",
        parse_mode='Markdown'
    )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == '__main__':
    mode = "ðŸ§ª TESTNET MODE" if USE_TESTNET else "ðŸ” PRODUCTION MODE"
    
    print("â•" * 50)
    print("ðŸ¤– VIP Premium Bot - Multi Payment Gateway")
    print("â•" * 50)
    print(f"Mode: {mode}")
    print(f"Price: ${int(FINAL_PRICE)} (was ${ORIGINAL_PRICE})")
    print("â•" * 50)
    print("Payment Gateways:")
    print("  ðŸ”· CryptoPay: Enabled")
    print(f"  ðŸŸ¡ KkPay: {'Configured' if KKPAY_ID != 'YOUR_KKPAY_ID' else 'Not configured'}")
    print(f"  ðŸŸ¢ OkayPay: {'Configured' if OKAYPAY_ID != 'YOUR_OKAYPAY_ID' else 'Not configured'}")
    print("â•" * 50)
    print("Bot running...")
    print("â•" * 50)
    
    bot.infinity_polling()
