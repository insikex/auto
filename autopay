#!/usr/bin/env python3
"""
KkPay Telegram Bot (single file)

Required environment variables:
  - BOT_TOKEN
  - KKPAY_ID
  - KKPAY_SECRET

Optional environment variables:
  - KKPAY_BASE_URL (default: https://www.gamepay.tech)
  - KKPAY_CONTENT_TYPE (default: text/plain)
  - KKPAY_TIMEOUT (seconds, default: 15)
  - KKPAY_ALLOW_UNSIGNED (true/false, default: false)
  - KKPAY_RETURN_URL (used for /pay)
  - KKPAY_CHECK_WITHDRAW_PATH (default: /api/merchant/checkWithdraw)
  - KKPAY_CENSOR_USER_PATH (default: /api/merchant/censorUserByTG)
  - ADMIN_ID (telegram user id for admin commands)
  - DEFAULT_COIN (default: USDT)
  - ORDER_PREFIX (default: tg)
"""

import base64
import hashlib
import hmac
import json
import os
import secrets
import time
from decimal import Decimal, ROUND_DOWN, InvalidOperation
import urllib.error
import urllib.request

import telebot
from telebot import types


BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
KKPAY_ID = os.getenv("KKPAY_ID", "").strip()
KKPAY_SECRET = os.getenv("KKPAY_SECRET", "").strip()

KKPAY_BASE_URL = os.getenv("KKPAY_BASE_URL", "https://www.gamepay.tech").rstrip("/")
KKPAY_CONTENT_TYPE = os.getenv("KKPAY_CONTENT_TYPE", "text/plain")
KKPAY_TIMEOUT = int(os.getenv("KKPAY_TIMEOUT", "15"))
KKPAY_ALLOW_UNSIGNED = os.getenv("KKPAY_ALLOW_UNSIGNED", "false").lower() == "true"
KKPAY_RETURN_URL = os.getenv("KKPAY_RETURN_URL", "").strip()

KKPAY_CHECK_WITHDRAW_PATH = os.getenv(
    "KKPAY_CHECK_WITHDRAW_PATH", "/api/merchant/checkWithdraw"
)
KKPAY_CENSOR_USER_PATH = os.getenv(
    "KKPAY_CENSOR_USER_PATH", "/api/merchant/censorUserByTG"
)

ADMIN_ID = int(os.getenv("ADMIN_ID", "0") or 0)
DEFAULT_COIN = os.getenv("DEFAULT_COIN", "USDT").upper()
ORDER_PREFIX = os.getenv("ORDER_PREFIX", "tg")

ALLOWED_COINS = {"USDT", "TRX", "CNY", "KKCOIN"}


def require_env():
    missing = []
    if not BOT_TOKEN:
        missing.append("BOT_TOKEN")
    if not KKPAY_ID:
        missing.append("KKPAY_ID")
    if not KKPAY_SECRET:
        missing.append("KKPAY_SECRET")
    if missing:
        raise SystemExit("Missing required environment variables: " + ", ".join(missing))


def normalize_coin(value):
    coin = value.upper()
    if coin not in ALLOWED_COINS:
        raise ValueError(
            "Unsupported coin. Allowed: " + ", ".join(sorted(ALLOWED_COINS))
        )
    return coin


def normalize_amount(value):
    try:
        amount = Decimal(str(value))
    except (InvalidOperation, ValueError, TypeError) as exc:
        raise ValueError("Invalid amount") from exc
    if amount <= 0:
        raise ValueError("Amount must be greater than 0")
    amount = amount.quantize(Decimal("0.01"), rounding=ROUND_DOWN)
    return float(amount)


def make_order_id(prefix, user_id):
    suffix = secrets.token_hex(3)
    return f"{prefix}-{user_id}-{int(time.time())}-{suffix}"


class KkPayError(Exception):
    pass


class KkPayClient:
    def __init__(
        self,
        merchant_id,
        secret,
        base_url,
        content_type="text/plain",
        timeout=15,
        allow_unsigned=False,
        check_withdraw_path="/api/merchant/checkWithdraw",
        censor_user_path="/api/merchant/censorUserByTG",
    ):
        self.merchant_id = merchant_id
        self.secret = secret
        self.base_url = base_url.rstrip("/")
        self.content_type = content_type
        self.timeout = timeout
        self.allow_unsigned = allow_unsigned
        self.check_withdraw_path = check_withdraw_path
        self.censor_user_path = censor_user_path

    def _sign(self, data_b64):
        raw = (data_b64 + self.secret).encode("utf-8")
        digest = hashlib.sha256(raw).digest()
        return base64.b64encode(digest).decode("ascii")

    def _post(self, path, payload):
        if not path.startswith("/"):
            path = "/" + path
        url = self.base_url + path

        body_json = json.dumps(payload, separators=(",", ":"), ensure_ascii=False)
        body_b64 = base64.b64encode(body_json.encode("utf-8")).decode("ascii")
        signature = self._sign(body_b64)

        req = urllib.request.Request(
            url,
            data=body_b64.encode("utf-8"),
            method="POST",
        )
        req.add_header("Content-Type", self.content_type)
        req.add_header("KKPAY-ID", self.merchant_id)
        req.add_header("KKPAY-SIGN", signature)

        try:
            with urllib.request.urlopen(req, timeout=self.timeout) as resp:
                body = resp.read().decode("utf-8", errors="replace").strip()
                resp_sign = resp.headers.get("KKPAY-SIGN", "").strip()
        except urllib.error.HTTPError as exc:
            body = exc.read().decode("utf-8", errors="replace").strip()
            raise KkPayError(f"HTTP {exc.code}: {body or exc.reason}")
        except Exception as exc:
            raise KkPayError(str(exc))

        return self._parse_response(body, resp_sign)

    def _parse_response(self, body, resp_sign):
        if body == "Oops":
            raise KkPayError("IP not whitelisted (Oops)")

        try:
            payload = json.loads(body)
        except json.JSONDecodeError:
            raise KkPayError(f"Invalid JSON response: {body[:200]}")

        code = payload.get("code")
        try:
            code_int = int(code)
        except (TypeError, ValueError):
            code_int = None

        message = payload.get("message", "")
        if code_int not in (10000, 1000):
            raise KkPayError(message or f"API error code {code}")

        data = payload.get("data")
        if data is None:
            return {}
        if isinstance(data, (dict, list)):
            return data
        if not isinstance(data, str):
            raise KkPayError("Unexpected data format in response")

        if resp_sign:
            expected = self._sign(data)
            if not hmac.compare_digest(expected, resp_sign):
                raise KkPayError("Response signature verification failed")
        elif not self.allow_unsigned:
            raise KkPayError("Missing response signature")

        try:
            decoded = base64.b64decode(data).decode("utf-8")
            return json.loads(decoded)
        except Exception as exc:
            raise KkPayError(f"Failed to decode response data: {exc}")

    def pay_link(self, payload):
        return self._post("/merchant/payLink", payload)

    def create_withdraw_order(self, payload):
        return self._post("/merchant/createWithdrawOrder", payload)

    def check_deposit(self, txid):
        return self._post("/merchant/checkDeposit", {"txid": txid})

    def check_withdraw(self, txid):
        return self._post(self.check_withdraw_path, {"txid": txid})

    def censor_user_by_tg(self, tg_id):
        return self._post(self.censor_user_path, {"tg_id": tg_id})


def is_admin(user_id):
    return ADMIN_ID and user_id == ADMIN_ID


def safe_call(fn, *args, **kwargs):
    try:
        return fn(*args, **kwargs), None
    except KkPayError as exc:
        return None, str(exc)
    except Exception as exc:
        return None, f"Unexpected error: {exc}"


def get_value(data, *keys):
    for key in keys:
        if key in data:
            return data.get(key)
    return ""


def format_deposit_status(data):
    currency = get_value(data, "currency", "coin")
    status = get_value(data, "statusText", "orderStatus")
    pay_user = get_value(data, "payUser", "pay_user")
    lines = [
        "Deposit status",
        f"txid: {data.get('txid', '')}",
        f"amount: {data.get('amount', '')}",
        f"currency: {currency}",
        f"fee: {data.get('fee', '')}",
        f"status: {status}",
    ]
    if pay_user:
        lines.append(f"pay_user: {pay_user}")
    if "name" in data:
        lines.append(f"name: {data.get('name', '')}")
    return "\n".join(lines)


def format_withdraw_status(data):
    currency = get_value(data, "currency", "coin")
    status = get_value(data, "orderStatus", "statusText")
    to_user_id = get_value(data, "to_user_id", "toUserId")
    lines = [
        "Withdraw status",
        f"txid: {data.get('txid', '')}",
        f"amount: {data.get('amount', '')}",
        f"currency: {currency}",
        f"fee: {data.get('fee', '')}",
        f"status: {status}",
    ]
    if "userOrder" in data:
        lines.append(f"user_order: {data.get('userOrder', '')}")
    if to_user_id:
        lines.append(f"to_user_id: {to_user_id}")
    if "name" in data:
        lines.append(f"name: {data.get('name', '')}")
    return "\n".join(lines)


def format_user_check(data):
    return f"tg_id: {data.get('tg_id', '')}\nexists: {data.get('isExist', '')}"


HELP_TEXT = (
    "KkPay bot ready.\n"
    "\n"
    "Commands:\n"
    "/pay <amount> [coin] [order_id]\n"
    "/check_deposit <txid>\n"
    "/withdraw <amount> <coin> <tg_id> [order_id] [note] (admin only)\n"
    "/check_withdraw <txid> (admin only)\n"
    "/check_user <tg_id> (admin only)\n"
    "\n"
    "Allowed coins: USDT, TRX, CNY, KKCOIN\n"
)


require_env()
bot = telebot.TeleBot(BOT_TOKEN)
client = KkPayClient(
    merchant_id=KKPAY_ID,
    secret=KKPAY_SECRET,
    base_url=KKPAY_BASE_URL,
    content_type=KKPAY_CONTENT_TYPE,
    timeout=KKPAY_TIMEOUT,
    allow_unsigned=KKPAY_ALLOW_UNSIGNED,
    check_withdraw_path=KKPAY_CHECK_WITHDRAW_PATH,
    censor_user_path=KKPAY_CENSOR_USER_PATH,
)


@bot.message_handler(commands=["start", "help"])
def cmd_help(message):
    bot.reply_to(message, HELP_TEXT)


@bot.message_handler(commands=["pay"])
def cmd_pay(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Usage: /pay <amount> [coin] [order_id]")
        return

    amount_text = args[1]
    coin_text = args[2] if len(args) > 2 else DEFAULT_COIN
    order_id = args[3] if len(args) > 3 else make_order_id(ORDER_PREFIX, message.from_user.id)

    try:
        amount = normalize_amount(amount_text)
        coin = normalize_coin(coin_text)
    except ValueError as exc:
        bot.reply_to(message, f"Input error: {exc}")
        return

    payload = {"userOrder": order_id, "amount": amount, "coin": coin}
    if KKPAY_RETURN_URL:
        payload["return_url"] = KKPAY_RETURN_URL

    data, error = safe_call(client.pay_link, payload)
    if error:
        bot.reply_to(message, f"Error: {error}")
        return

    txid = data.get("txid", "")
    pay_url = get_value(data, "pay_url", "payUrl")
    currency = get_value(data, "currency", "coin") or coin
    reply_lines = [
        "Payment link created",
        f"user_order: {order_id}",
        f"txid: {txid}",
        f"amount: {data.get('amount', amount)}",
        f"currency: {currency}",
        f"fee: {data.get('fee', '')}",
        f"pay_url: {pay_url}",
    ]

    kb = types.InlineKeyboardMarkup()
    if txid:
        kb.add(
            types.InlineKeyboardButton(
                "Check payment", callback_data=f"checkdep:{txid}"
            )
        )
    bot.send_message(message.chat.id, "\n".join(reply_lines), reply_markup=kb)


@bot.message_handler(commands=["check_deposit"])
def cmd_check_deposit(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Usage: /check_deposit <txid>")
        return
    txid = args[1]

    data, error = safe_call(client.check_deposit, txid)
    if error:
        bot.reply_to(message, f"Error: {error}")
        return
    bot.reply_to(message, format_deposit_status(data))


@bot.message_handler(commands=["withdraw"])
def cmd_withdraw(message):
    if not is_admin(message.from_user.id):
        bot.reply_to(message, "Admin only command.")
        return

    args = message.text.split()
    if len(args) < 4:
        bot.reply_to(message, "Usage: /withdraw <amount> <coin> <tg_id> [order_id] [note]")
        return

    amount_text = args[1]
    coin_text = args[2]
    tg_id_text = args[3]
    order_id = args[4] if len(args) > 4 else make_order_id("wd", tg_id_text)
    note = " ".join(args[5:]) if len(args) > 5 else ""

    try:
        amount = normalize_amount(amount_text)
        coin = normalize_coin(coin_text)
        tg_id = int(tg_id_text)
    except (ValueError, TypeError) as exc:
        bot.reply_to(message, f"Input error: {exc}")
        return

    payload = {
        "userOrder": order_id,
        "amount": amount,
        "coin": coin,
        "to_user_id": tg_id,
    }
    if note:
        payload["name"] = note

    data, error = safe_call(client.create_withdraw_order, payload)
    if error:
        bot.reply_to(message, f"Error: {error}")
        return

    reply_lines = [
        "Withdraw order created",
        f"user_order: {order_id}",
        f"txid: {data.get('txid', '')}",
        f"amount: {data.get('amount', amount)}",
        f"currency: {data.get('currency', coin)}",
        f"fee: {data.get('fee', '')}",
    ]
    bot.reply_to(message, "\n".join(reply_lines))


@bot.message_handler(commands=["check_withdraw"])
def cmd_check_withdraw(message):
    if not is_admin(message.from_user.id):
        bot.reply_to(message, "Admin only command.")
        return
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Usage: /check_withdraw <txid>")
        return
    txid = args[1]

    data, error = safe_call(client.check_withdraw, txid)
    if error:
        bot.reply_to(message, f"Error: {error}")
        return
    bot.reply_to(message, format_withdraw_status(data))


@bot.message_handler(commands=["check_user"])
def cmd_check_user(message):
    if not is_admin(message.from_user.id):
        bot.reply_to(message, "Admin only command.")
        return
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Usage: /check_user <tg_id>")
        return
    tg_id = args[1]

    data, error = safe_call(client.censor_user_by_tg, tg_id)
    if error:
        bot.reply_to(message, f"Error: {error}")
        return
    bot.reply_to(message, format_user_check(data))


@bot.callback_query_handler(func=lambda call: call.data.startswith("checkdep:"))
def cb_check_deposit(call):
    txid = call.data.split(":", 1)[1]
    data, error = safe_call(client.check_deposit, txid)
    if error:
        bot.answer_callback_query(call.id, "Check failed", show_alert=True)
        bot.send_message(call.message.chat.id, f"Error: {error}")
        return

    bot.answer_callback_query(call.id, "Status updated")
    bot.send_message(call.message.chat.id, format_deposit_status(data))


@bot.message_handler(func=lambda _: True)
def default_handler(message):
    bot.reply_to(message, "Unknown command. Use /help for instructions.")


if __name__ == "__main__":
    print("Starting KkPay bot")
    print(f"Base URL: {KKPAY_BASE_URL}")
    print(f"Merchant ID: {KKPAY_ID}")
    print(f"Default coin: {DEFAULT_COIN}")
    if ADMIN_ID:
        print(f"Admin ID: {ADMIN_ID}")
    else:
        print("Admin commands disabled (ADMIN_ID not set)")
    bot.infinity_polling()
